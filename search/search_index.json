{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SDE Interview Prep 2026","text":"<p>Systematic preparation for coding interviews covering DSA, System Design, and behavioral preparation.</p>"},{"location":"#your-interview-prep-repositories","title":"\ud83d\udcda Your Interview Prep Repositories","text":""},{"location":"#dsa-prep","title":"\ud83d\udcca DSA Prep","text":"<p>Data Structures &amp; Algorithms practice with detailed solutions, complexity analysis, and pattern identification.</p> <p>Goal: 100+ problems over 115 hours Repository: https://github.com/madhuedipelli/dsa</p>"},{"location":"#system-design","title":"\ud83c\udfd7\ufe0f System Design","text":"<p>High-level and low-level design patterns with case studies, tradeoff analysis, and architectural principles.</p> <p>Goal: Master 10+ design patterns in 30 hours Repository: https://github.com/madhuedipelli/system-design</p>"},{"location":"#java-spring","title":"\u2615 Java &amp; Spring","text":"<p>Concurrency patterns and Spring Boot best practices for interview preparation (optional, based on tech stack).</p> <p>Repository: https://github.com/madhuedipelli/java-concurrency-spring</p>"},{"location":"#interview-guide","title":"\ud83c\udfaf Interview Guide","text":"<p>Based on \"You Suck At Coding Interviews\" - comprehensive analysis from former Apple and Uber engineers.</p> <ul> <li>\ud83d\udcd6 DSA Interview Guide - 7 gotchas &amp; strategies for data structures &amp; algorithms</li> <li>\ud83d\udcd6 System Design Guide - 7 gotchas &amp; strategies for system design</li> <li>\u23f1\ufe0f Study Timelines - Benchmarks &amp; milestones (DSA: 115h, System Design: 30h)</li> <li>\u2705 Interview Checklists - Readiness checklists &amp; mindset shifts</li> <li>\ud83d\udcdd Practice Diary - Template &amp; guidelines for tracking mistakes</li> </ul>"},{"location":"#core-learning-principle","title":"\ud83c\udf93 Core Learning Principle","text":"<p>\"Avoid mistakes rather than seek excellence. Not making ANY mistakes beats trying to be brilliant and failing.\"</p> <p>Apply this to both DSA AND System Design. Consistency &gt; Speed</p> <p>Last Updated: February 15, 2026</p>"},{"location":"checklists/","title":"\u2705 Interview Readiness Checklists","text":""},{"location":"checklists/#dsa-readiness-checklist","title":"DSA Readiness Checklist","text":""},{"location":"checklists/#can-you-solve-problems","title":"Can You Solve Problems?","text":"<ul> <li>[ ] Completed 60%+ of Grokking patterns</li> <li>[ ] Completed EPI chapters 5-16</li> <li>[ ] Can solve 70% of 20 random medium problems first try</li> <li>[ ] Can solve ANY problem with infinite time (just slow)</li> <li>[ ] Only mistakes are edge cases, not core algorithm logic</li> <li>[ ] Practice diary filled with 50+ problems</li> <li>[ ] Can speed-run 5 problems in 45-60 min total</li> </ul>"},{"location":"checklists/#can-you-explain-solutions","title":"Can You Explain Solutions?","text":"<ul> <li>[ ] Can explain approach WITHOUT looking at notes</li> <li>[ ] Can describe preconditions for each pattern</li> <li>[ ] Can compare naive vs optimal (tradeoffs)</li> <li>[ ] Can identify why pattern works for THIS problem</li> <li>[ ] Can handle \"why not approach X?\" questions</li> </ul>"},{"location":"checklists/#can-you-code-cleanly","title":"Can You Code Cleanly?","text":"<ul> <li>[ ] Variable names clear, meaningful</li> <li>[ ] No off-by-one errors in recent problems</li> <li>[ ] Edge cases tested on paper FIRST</li> <li>[ ] Code compiles on first try (usually)</li> <li>[ ] Can refactor on request without hesitation</li> </ul>"},{"location":"checklists/#speed-achieved","title":"Speed Achieved?","text":"Level Target Your Time Status Easy 5 min ___ \u2705/\u274c Medium 20 min ___ \u2705/\u274c Hard 35 min ___ \u2705/\u274c <p>Pass Criteria: All 3 \u2705</p>"},{"location":"checklists/#consistency-achieved","title":"Consistency Achieved?","text":"<ul> <li>[ ] Last 10 problems: 80%+ success rate</li> <li>[ ] Code quality consistent (no regressions)</li> <li>[ ] Speed improving or stable (not getting slower)</li> <li>[ ] Same mistakes NOT reappearing</li> </ul>"},{"location":"checklists/#system-design-readiness-checklist","title":"System Design Readiness Checklist","text":""},{"location":"checklists/#have-you-studied","title":"Have You Studied?","text":"<ul> <li>[ ] Completed 5-10 case studies in depth (Grokking)</li> <li>[ ] Read DDIA chapters on weak areas (Ch 5, 6, 9, 11)</li> <li>[ ] Designed 3-5 systems from scratch (URL Shortener, Twitter, YouTube, Uber, Messaging)</li> <li>[ ] Compared your designs to reference solutions</li> <li>[ ] Identified gaps in your reasoning</li> </ul>"},{"location":"checklists/#can-you-calculate-capacity","title":"Can You Calculate Capacity?","text":"<p>Given: \"Design Twitter\"</p> <p>Calculate within 10 minutes: - [ ] DAU estimation - [ ] QPS calculation (write + read) - [ ] Storage requirement (1-year, 5-year) - [ ] Bandwidth calculation - [ ] Peak load scenarios</p> <p>Pass Criteria: All 5 accurate within 20% error margin</p>"},{"location":"checklists/#can-you-design-systems","title":"Can You Design Systems?","text":"<p>Given: Any system design problem</p> <ul> <li>[ ] Define requirements (NFRs) in first 2 min</li> <li>[ ] Draw HLD with all components in 5 min</li> <li>[ ] Identify and quantity each component's need</li> <li>[ ] Design data model (tables/collections) correctly</li> <li>[ ] Handle at least 2 failure scenarios</li> <li>[ ] Justify why EACH component exists</li> <li>[ ] Run all components through load</li> </ul> <p>Pass Criteria: Can do this with minimal help</p>"},{"location":"checklists/#can-you-handle-tradeoffs","title":"Can You Handle Tradeoffs?","text":"<p>Given: Any system design choice</p> <ul> <li>[ ] Explicitly state what you're sacrificing</li> <li>[ ] Explain why the sacrifice is worth it</li> <li>[ ] Identify monitoring to detect problems</li> <li>[ ] Have a backup plan if issue arises</li> </ul> <p>Examples You Should Nail:</p> <pre><code>\u2705 \"Hash-based sharding: sacrifice re-distribution complexity,\n   gain even distribution, monitor hot shards\"\n\n\u2705 \"Eventual consistency: sacrifice strong consistency,\n   gain horizontal scale, accept 1s stale reads\"\n\n\u2705 \"In-memory cache: sacrifice memory cost,\n   gain 100x faster reads, monitor hit rate\"\n</code></pre> <p>Pass Criteria: Can explain 10 tradeoffs clearly</p>"},{"location":"checklists/#can-you-identify-failures","title":"Can You Identify Failures?","text":"<p>Given: Your design</p> <p>Identify and handle: - [ ] Network partition (timeout/failover strategy) - [ ] Database crash (replication/backup strategy) - [ ] Replica lag (read-after-write consistency) - [ ] Cache miss (fallback strategy) - [ ] Cascading failures (circuit breaker strategy) - [ ] Data corruption (verification/recovery)</p> <p>Pass Criteria: Can design recovery for 5/6</p>"},{"location":"checklists/#communication-skills","title":"Communication Skills","text":"<ul> <li>[ ] Explain design clearly in plain English</li> <li>[ ] Adjust explanation level to interviewer</li> <li>[ ] Listen to hints and incorporate feedback</li> <li>[ ] Ask clarifying questions</li> <li>[ ] Can draw (or ASCII) architecture clearly</li> </ul>"},{"location":"checklists/#mindset-checklist","title":"Mindset Checklist","text":""},{"location":"checklists/#shift-fromto","title":"Shift From...To","text":"<ul> <li>[ ] Memorization \u2192 Understanding</li> <li>[ ] Can explain WHY slides window works (precondition)</li> <li>[ ] Understand replication consistency models (not just \"use replication\")</li> <li> <p>[ ] Know when algorithm breaks (edge cases)</p> </li> <li> <p>[ ] Speed \u2192 Consistency</p> </li> <li>[ ] Fast incorrect &lt; Slow correct</li> <li>[ ] Track your error rate (should be dropping)</li> <li> <p>[ ] Makes same mistakes 0 times (goal)</p> </li> <li> <p>[ ] Complexity \u2192 Simplicity</p> </li> <li>[ ] \"Simpler is usually better\" mindset</li> <li>[ ] No premature optimization</li> <li> <p>[ ] Explain in plainest words possible</p> </li> <li> <p>[ ] Patterns \u2192 Preconditions</p> </li> <li>[ ] Know when pattern applies</li> <li>[ ] Not just \"this looks like that problem\"</li> <li> <p>[ ] Precondition: check explicitly</p> </li> <li> <p>[ ] Tech Stacks \u2192 Reasoning</p> </li> <li>[ ] Never say \"Kafka because it's cool\"</li> <li>[ ] Always \"Kafka because we need to decouple at scale\"</li> <li>[ ] Can defend every technology choice</li> </ul>"},{"location":"checklists/#pre-interview-checklist-1-week-before","title":"Pre-Interview Checklist (1 Week Before)","text":""},{"location":"checklists/#dsa-prep","title":"DSA Prep","text":"<ul> <li>[ ] Run 5 timed mock problems (20 min each)</li> <li>[ ] Get 4/5 or more correct</li> <li>[ ] Review any bugs (don't repeat)</li> <li>[ ] Test on live judge (LeetCode Discuss, etc.)</li> <li>[ ] Sleep well, review patterns once (don't cram)</li> </ul>"},{"location":"checklists/#system-design-prep","title":"System Design Prep","text":"<ul> <li>[ ] Do 1-2 mock system design interviews (timed)</li> <li>[ ] Record yourself (watch for clarity)</li> <li>[ ] Get feedback on tradeoff discussion</li> <li>[ ] Verify calculations quickly</li> <li>[ ] Practice explaining under pressure</li> </ul>"},{"location":"checklists/#general","title":"General","text":"<ul> <li>[ ] Review gotchas list (memorize)</li> <li>[ ] Prepare questions for interviewer</li> <li>\"What's your biggest scale challenge?\"</li> <li>\"What systems are you most proud to have designed?\"</li> <li>\"What early-career mistakes shaped your design philosophy?\"</li> <li>[ ] Equipment check</li> <li>Quiet room \u2705</li> <li>Webcam working \u2705</li> <li>IDE installed and tested \u2705</li> <li>Whiteboard/pen (for drawing) \u2705</li> </ul>"},{"location":"checklists/#interview-day-checklist","title":"Interview Day Checklist","text":""},{"location":"checklists/#before-interview-starts","title":"Before Interview Starts","text":"<ul> <li>[ ] 30 min early for any setup issues</li> <li>[ ] Brain warm-up: solve 1 easy problem</li> <li>[ ] Hydrate, bathroom break, stretching</li> <li>[ ] Phone/notifications silenced</li> <li>[ ] Clear mind: no worrying, just focus</li> </ul>"},{"location":"checklists/#during-dsa-interview","title":"During DSA Interview","text":"<ul> <li>[ ] First: Clarify requirements (2 min)</li> <li>[ ] Second: Naive approach on paper (3 min)</li> <li>[ ] Third: Optimize and discuss (5 min)</li> <li>[ ] Fourth: Code carefully (10 min)</li> <li>[ ] Fifth: Test on examples (3 min)</li> <li>[ ] Sixth: Ask about follow-ups</li> </ul>"},{"location":"checklists/#during-system-design-interview","title":"During System Design Interview","text":"<ul> <li>[ ] First: Define requirements &amp; NFRs (3 min)</li> <li>[ ] Second: Capacity calculations (5 min)</li> <li>[ ] Third: HLD diagram (5 min)</li> <li>[ ] Fourth: Identify bottlenecks (3 min)</li> <li>[ ] Fifth: Propose solutions (5 min)</li> <li>[ ] Sixth: Discuss tradeoffs (5 min)</li> <li>[ ] Seventh: Handle failures (3 min)</li> </ul>"},{"location":"checklists/#failure-mode-recovery","title":"Failure Mode Recovery","text":""},{"location":"checklists/#if-you-blank-on-a-pattern","title":"If You Blank on a Pattern","text":"<pre><code>\u274c Don't: \"I forgot, sorry\"\n\n\u2705 Do: \"Let me think through this...\n        Problem: find subarray\n        Precondition: can we reuse? Yes\n        Pattern: sliding window\n        Let me code it up...\"\n</code></pre>"},{"location":"checklists/#if-you-write-buggy-code","title":"If You Write Buggy Code","text":"<pre><code>\u274c Don't: Submit and hope\n\n\u2705 Do: \"Let me trace through an example\n       [1,2,3,4] k=2\n       Window 0: [1,2] sum=3\n       Window 1: [2,3] sum=5\n       Output: 3,5\n\n       Code check: for i=0 \u2192 0+2=2 \u2192 array[0:2]=[1,2] \u2713\n       Code check: for i=2 \u2192 2+2=4 \u2192 array[2:4]=[3,4]\u2713\n\n       Tests good, let me submit\"\n</code></pre>"},{"location":"checklists/#if-interviewer-questions-your-choice","title":"If Interviewer Questions Your Choice","text":"<pre><code>\u274c Don't: Defend furiously\n\n\u2705 Do: \"Good point. Let me think...\n       MySQL: strong consistency but hard scale\n       Cassandra: scales horizontally but eventual consistency\n       Given [requirement], Cassandra makes sense.\n       BUT if [other requirement], MySQL would be better.\n       Trade-off: consistency vs scalability\"\n</code></pre>"},{"location":"checklists/#if-you-get-stuck","title":"If You Get Stuck","text":"<pre><code>\u2705 Ask: \"Can I clarify the requirements?\"\n\u2705 Ask: \"Should I optimize for reads or writes?\"\n\u2705 Think out loud: \"Let me consider approaches...\n                   Approach 1: ...\n                   Trade-off: ...\n                   I'll try...\"\n\u274c Don't stay silent for &gt; 30 seconds\n</code></pre>"},{"location":"checklists/#post-interview-reflection","title":"Post-Interview Reflection","text":""},{"location":"checklists/#what-went-well","title":"What Went Well?","text":"<ul> <li>[ ] Clarified requirements clearly</li> <li>[ ] Explained approach before coding</li> <li>[ ] Tested edge cases</li> <li>[ ] Handled feedback</li> <li>[ ] Communication clear</li> </ul>"},{"location":"checklists/#what-to-improve","title":"What To Improve?","text":"<ul> <li>[ ] Spent too much time on [X]</li> <li>[ ] Forgot to [Y]</li> <li>[ ] Tradeoff discussion weak</li> <li>[ ] Code could be cleaner</li> <li>[ ] Speed was slow</li> </ul>"},{"location":"checklists/#next-interview-adjustments","title":"Next Interview Adjustments","text":"<ul> <li>[ ] Practice [X] more</li> <li>[ ] Time-box[Y] section</li> <li>[ ] Prepare for [Z] follow-up</li> <li>[ ] Speed up [W]</li> </ul> <p>You're Ready When: All main checklists \u2705, last 3 mocks scored well, consistent performance, no panic</p> <p>Good luck! \ud83d\ude80</p>"},{"location":"dsa-guide/","title":"\ud83d\udcd6 DSA Interview Guide","text":""},{"location":"dsa-guide/#the-7-dsa-gotchas-to-avoid","title":"The 7 DSA Gotchas to Avoid","text":"<p>Based on comprehensive analysis of \"You Suck At Coding Interviews\" guide.</p>"},{"location":"dsa-guide/#1-the-magic-bullet-trap-most-common","title":"1\ufe0f\u20e3 The Magic Bullet Trap \u2b50 MOST COMMON","text":"<p>Problem: Jumping straight to optimal solution, failing when wrong, wasting 20+ minutes.</p> <p>Why It Happens: Overconfidence + no fallback strategy</p> <p>The Numbers: - Saves 5 minutes if optimal works - LOSES 20+ minutes if it fails - Net cost: -15 minutes</p> <p>Fix: Always start naive \u2192 optimize incrementally \u2192 test baseline</p> <p>Your Takeaway: In interview, propose naive first, get feedback, then optimize.</p> <p>Example:</p> <pre><code>\u274c WRONG: \"I'll use two-pointers in O(n) time\"\n   \u2192 Realizes pointers need sorted input\n   \u2192 Spends 15 minutes reworking\n   \u2192 Rushes through solution\n   \u2192 Misses edge cases\n\n\u2705 RIGHT: \"I'll start with naive O(n\u00b2) brute force\"\n   \u2192 Interviewer confirms approach\n   \u2192 \"Good, now optimize?\"\n   \u2192 Proposes two-pointers with clear preconditions\n   \u2192 Has time to test edge cases\n</code></pre>"},{"location":"dsa-guide/#2-not-testing-on-paper","title":"2\ufe0f\u20e3 Not Testing on Paper","text":"<p>Problem: Algorithm works in your head but fails when you trace through it.</p> <p>Why It Happens: Brains are terrible at precise mental computation with multiple variables</p> <p>Real Example: Reversing linked list</p> <pre><code>Input: [4, 5, 1, 3, 2]\nYour head: \"Works in reverse!\"\nOn paper: \n  - Step 1: prev=null, current=4\n  - Step 2: next=5, 4.next=null\n  - Step 3: prev=4, current=5\n  - ...realizes you're overwriting pointers incorrectly\n</code></pre> <p>Fix: BEFORE coding anything: 1. Pick small input (3-4 elements) 2. Draw state diagram 3. Write every variable value per step 4. Identify where logic breaks</p> <p>Your Action: Must trace through 2-3 examples on paper EVERY TIME</p> <p>Practice Tip: If it works on paper for 3 cases, you've caught 80% of bugs before coding</p>"},{"location":"dsa-guide/#3-speed-understanding-critical","title":"3\ufe0f\u20e3 Speed \u2260 Understanding \u2b50 CRITICAL","text":"<p>The Myth: \"I can solve it if I have time\"</p> <p>The Reality:</p> Level Time Expected Your Autonomy L3 30+ minutes Learning L4 15 minutes Competent L5 3-5 minutes Expert <p>The Truth: If not autonomous (3-5 min for L5), go back and redo</p> <p>Example: If at 50 hours, still taking 20 min for easy problems: - Stop solving new problems - Re-study the pattern completely - Understand the preconditions - Then resume practice</p> <p>Fix: Track time per problem, watch for improvement curve</p> <p>Your Metric: - @5h: Easy ~15 min - @20h: Easy &lt; 10 min - @50h: Easy &lt; 5 min - @100h: Easy &lt; 2 min</p> <p>Red Flag: If your times are staying flat or increasing, you're memorizing, not understanding</p>"},{"location":"dsa-guide/#4-only-memorizing-solutions","title":"4\ufe0f\u20e3 Only Memorizing Solutions","text":"<p>Problem: Watch/read solution, think you get it, move on. Can't apply to variations.</p> <p>Why Fails: Memorized facts without underlying logic can't transfer to new contexts</p> <p>The Numbers: - 20 deeply understood problems &gt; 100 memorized problems - Memorization fails when problem is 10% different - Understanding succeeds even with 50% variation</p> <p>Fix: For EACH solution, reverse-engineer:</p> <ol> <li>Problem Characteristics: What about this problem made this approach optimal?    ```    Example: Sliding window works because:</li> <li>Non-relational data (sum)</li> <li>Can reuse portion of previous result</li> <li> <p>Problem asks for subarray    ```</p> </li> <li> <p>Inefficiencies in Naive: What was the inefficiency?    <code>Example: Naive = recalculate sum for every window    Inefficiency = O(n\u00b2) recalculation</code></p> </li> <li> <p>Bridge: What insight connects naive to optimal?    <code>Example: If last window sum is known,    current window = last - left_element + right_element    Precondition: \"contract then expand\" window pattern</code></p> </li> </ol> <p>Outcome: When you see a new problem: - Recognize preconditions first - THEN apply pattern - NOT: \"This looks like the problem I memorized\"</p>"},{"location":"dsa-guide/#5-pattern-confusion-overlap","title":"5\ufe0f\u20e3 Pattern Confusion Overlap","text":"<p>Problem: After learning many patterns, preconditions overlap and confuse you</p> <p>Example Confusion:</p> <pre><code>Two Pointers: When?\nSliding Window: When?\nBinary Search: Which condition?\nBFS vs DFS: Which to use?\n</code></pre> <p>Why Happens: Preconditions aren't explicit, they're implicit in examples</p> <p>Fix: After learning new pattern, backtest against previous 5 problems</p> <p>Process:</p> <pre><code>New pattern: Sliding Window learned\nYour action: \n  1. Take 5 previous problems\n  2. Would sliding window work?\n  3. Why or why not?\n  4. Write down precondition\n  5. Test this precondition on current pattern examples\n</code></pre> <p>Your Timeline: Spend 30 min per new pattern on overlap checking</p> <p>Red Flag: If confused on new pattern \u2192 You didn't understand old one</p> <p>Document Template:</p> <pre><code>## Sliding Window Pattern\n**Precondition:** Non-relational data + can reuse portion\n\n\u2705 Works: Max sum subarray (reuse = remove left + add right)\n\u2705 Works: Longest substring (reuse = slide window)\n\u274c Doesn't: Merge intervals (relational, changes per element)\n\u274c Doesn't: LIS (position dependency too high)\n</code></pre>"},{"location":"dsa-guide/#6-the-sliding-window-trap","title":"6\ufe0f\u20e3 The Sliding Window Trap","text":"<p>Problem: Students memorize \"use sliding window for subarrays\" without understanding WHY</p> <p>Root Cause: No formal CS education on this pattern exists in textbooks; must infer from examples</p> <p>Fix: Learn the PRECONDITION first, NOT the name</p> <p>Precondition: </p> <pre><code>\"Can we reuse a portion of the previous computation?\"\n\nYES \u2192 Consider sliding window\nNO \u2192 You need different approach\n</code></pre> <p>In Your Prep: When learning sliding window, ask: - \"Why does reusing the sum work?\" - \"What would break if data was relational?\" - \"What if we couldn't contract the window?\"</p> <p>Example Breakdown:</p> <pre><code>Max Sum Subarray of size K\n\n\u274c Naive: Recalculate sum each window - O(n\u00b2)\n   Why slow? Throwing away previous work\n\n\u2705 Sliding Window: Reuse sum - O(n)\n   Why fast? Remove leftmost, add rightmost\n\nPrecondition met? \n  \"Can we remove old data without affecting new?\" YES\n  \"Is order specific?\" NO\n  \"Can we parallel process?\" NO (sequential)\n\n\u2705 Sliding window valid\n</code></pre>"},{"location":"dsa-guide/#7-skipping-edge-cases-in-planning","title":"7\ufe0f\u20e3 Skipping Edge Cases in Planning","text":"<p>Problem: Code first, realize edge cases after</p> <p>Cost: - Wasted coding time rewriting logic - Bugs that fail in interview - Panic and rush through solution</p> <p>Fix: BEFORE coding, list all edge cases</p> <p>Complete Edge Case Checklist:</p> <pre><code>## For every problem, check:\n\n### Input Size\n- [ ] Empty input ([], \"\", 0)\n- [ ] Single element ([1], \"a\", 1)\n- [ ] Two elements ([1,2], \"ab\", 2)\n\n### Duplicates &amp; Repetition\n- [ ] All duplicates ([1,1,1])\n- [ ] Multiple duplicates (\"aabbaa\")\n\n### Ordering\n- [ ] Already sorted ([1,2,3,4,5])\n- [ ] Reverse sorted ([5,4,3,2,1])\n- [ ] Random order\n\n### Values\n- [ ] All positive numbers\n- [ ] All negative numbers\n- [ ] Mix of positive/negative\n- [ ] Zeros present\n- [ ] Very large numbers (overflow?)\n- [ ] Very small numbers (underflow?)\n\n### Constraints\n- [ ] Min range (0 or 1?)\n- [ ] Max range (depends on memory)\n- [ ] Off-by-one boundaries (indices)\n\n### Special Cases (per problem)\n- [ ] [Your custom cases]\n</code></pre> <p>Your Process: 1. Read problem 2. Generate edge cases (5 min) 3. Test naive on paper (3 min) 4. Test edge cases on paper (5 min) 5. THEN code (much faster, fewer bugs)</p> <p>Time Saved: 5-10 min of debugging in interview = huge confidence boost</p>"},{"location":"dsa-guide/#dsa-study-strategy","title":"DSA Study Strategy","text":"<p>Based on the guide, here's the proven approach:</p>"},{"location":"dsa-guide/#the-four-step-problem-solving-method","title":"The Four-Step Problem Solving Method","text":"<ol> <li>Naive Solution (Baseline)</li> <li>Always code something</li> <li>Even if O(n\u00b2), have a working solution</li> <li> <p>Builds confidence</p> </li> <li> <p>Identify Inefficiency</p> </li> <li>What's slow?</li> <li>Why is it slow?</li> <li> <p>Can it be reused?</p> </li> <li> <p>Optimize</p> </li> <li>Apply pattern</li> <li>Test preconditions</li> <li> <p>Implement</p> </li> <li> <p>Test &amp; Refine</p> </li> <li>Edge cases first</li> <li>Boundary conditions</li> <li>Trace on paper</li> </ol>"},{"location":"dsa-guide/#the-practice-diary-mandatory","title":"The Practice Diary (MANDATORY)","text":"<p>Every problem you solve, you must record: - Time spent - Mistakes made + root cause - Prevention steps - Related problems</p> <p>This is the difference between solving 100 problems and LEARNING from 50 problems.</p>"},{"location":"dsa-guide/#benchmarks","title":"Benchmarks","text":"Hour Milestone What You Can Do 5h Starting Easy problems, heavy help needed 20h Foundation Easy problems in &lt; 10 min 50h Intermediate Easy/medium in &lt; 20 min, starting patterns 80h Advanced Most mediums solvable, patterns clear 100h Near Ready 70% of 20 random problems on first try 115h Ready Interview confident, thinking clearly <p>Next Step: See Practice Diary guide to structure your learning &gt;&gt;</p>"},{"location":"practice-diary/","title":"\ud83d\udcdd Practice Diary Guide","text":"<p>The practice diary is MANDATORY - it's the difference between solving 100 problems and LEARNING from them.</p>"},{"location":"practice-diary/#why-practice-diary-matters","title":"Why Practice Diary Matters","text":"<p>Statistic from interview guide: Candidates who keep practice diaries: - 70% improve in consistency over time - 50% catch recurring mistake patterns - Rarely repeat same mistake twice</p> <p>Candidates without practice diary: - 20% improvement rate - Repeat same mistakes 3-5 times - Hit plateau at 50-60h mark</p>"},{"location":"practice-diary/#the-practice-diary-template","title":"The Practice Diary Template","text":"<p>Create one markdown file per problem. Example: <code>2025-02-15-two-sum.md</code></p> <pre><code># Two Sum\n\n**Date:** February 15, 2026  \n**Time Spent:** 28 minutes  \n**Result:** \u2705 Passed / \u26a0\ufe0f Partial / \u274c Failed  \n**Attempt:** 1st attempt / 2nd attempt / 3rd attempt  \n\n## Problem Statement\nTwo integers in array sum to target, return indices\n\n## Approach\n- Naive: O(n\u00b2) brute force\n- Optimal: O(n) hash map - single pass\n\n## Solution\n\n### Brute Force (Baseline)\n```python\ndef twoSum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n</code></pre> <p>Complexity: O(n\u00b2) time, O(1) space</p>"},{"location":"practice-diary/#optimal-hash-map","title":"Optimal (Hash Map)","text":"<pre><code>def twoSum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n</code></pre> <p>Complexity: O(n) time, O(n) space</p>"},{"location":"practice-diary/#mistakes-made","title":"Mistakes Made","text":""},{"location":"practice-diary/#mistake-1-off-by-one-index","title":"Mistake 1: Off-by-One Index","text":"<p>What I Did: Returned <code>[i, j]</code> after loop, wrong indices Why: Forgot to store index while building map Cost: 5 minutes debugging Prevention: \"Always store index IN the dictionary iteration\"</p>"},{"location":"practice-diary/#mistake-2-didnt-check-edge-case","title":"Mistake 2: Didn't Check Edge Case","text":"<p>What I Did: Assumed array always has solution Why: Problem didn't explicitly say \"always has answer\" Cost: Would fail on empty array Prevention: \"Read problem for edge cases BEFORE coding\"</p>"},{"location":"practice-diary/#decision-chain","title":"Decision Chain","text":"<pre><code>Start \u2192 \"Two numbers sum to target?\"\n     \u2192 \"Naive: brute force O(n\u00b2)\" \u2713 Understood\n     \u2192 \"Optimal: speed up lookup?\" \n     \u2192 \"Use hash map for O(1) lookup\" \u2713 Right\n     \u2192 \"Store num\u279cindex mapping\" \u2713 Right\n     \u2192 \"Check complement exists BEFORE storing\" \u26a0\ufe0f Tricky\n     \u2192 \"Finally: handle no solution edge case\" \u2713 Right\n</code></pre> <p>Key Decision Point: Check complement BEFORE storing (order matters!)</p>"},{"location":"practice-diary/#testing-trace","title":"Testing Trace","text":"<pre><code>Input: [2, 7, 11, 15], target = 9\n\nIteration 1: num=2, complement=7, seen={}, store: seen[2]=0\nIteration 2: num=7, complement=2, seen[2] exists! Return [0, 1] \u2713\n\nInput: [1,1,1], target = 3\nIteration 1: num=1, complement=2, seen={}, store: seen[1]=0\nIteration 2: num=1, complement=2, seen={1}, store: seen[1]=1\nIteration 3: num=1, complement=2, seen={1}, store: seen[1]=2\nReturn [] \u2713 Edge case handled\n</code></pre>"},{"location":"practice-diary/#key-insights","title":"Key Insights","text":"<ol> <li> <p>Precondition for one-pass hash map:     Need to store value\u2192index, check OTHER value existed previously</p> </li> <li> <p>Why this matters:     Two-pass (build map, then search) is safer but slower</p> </li> <li> <p>Pattern recognition:     Any problem where \"lookup value\" = \"search previous results\" \u2192 hash map works</p> </li> </ol>"},{"location":"practice-diary/#similar-problems","title":"Similar Problems","text":"Problem Similarity Why Different 3Sum Similar: find targets Harder: 3 values, still use hashes Two Sum II Similar: find pair Different: array pre-sorted (use two pointers!) Closest Sum Similar: hash map Harder: need closest, not exact"},{"location":"practice-diary/#related-follow-ups","title":"Related Follow-ups","text":"<p>Interviewer might ask: 1. \"What if we need ALL pairs?\" \u2192 O(n) still works, store list 2. \"What if there are duplicates?\" \u2192 Edge case traced \u2713 3. \"What if array is sorted?\" \u2192 Could use two-pointers O(n) but use hashes OK 4. \"What about space constraints?\" \u2192 Trade O(n) space vs O(n\u00b2) time</p>"},{"location":"practice-diary/#time-analysis","title":"Time Analysis","text":"<ul> <li>Thinking: 2 min (understood problem)</li> <li>Naive: 3 min (wrote brute force)</li> <li>Optimal: 5 min (thought about hash map)</li> <li>Coding: 12 min (wrote solution)</li> <li>Testing: 6 min (traced examples)</li> <li>Total: 28 min</li> </ul> <p>Speed Assessment: - 28 min = slow for easy problem (target 5-10 min) - After 20h practice: should be 5 min - After 50h practice: should be 2 min - Track this to ensure improvement</p>"},{"location":"practice-diary/#lessons-for-future","title":"Lessons for Future","text":"<p>\u2705 Do: - Hash map for \"lookup\" problems - Store metadata (indices) not just keys - Check edge cases on paper first - Trace through examples methodically</p> <p>\u274c Avoid: - Assuming array always has solution - Off-by-one errors in index storage - Coding without tracing first</p>"},{"location":"practice-diary/#repeat-this-format-for-every-problem","title":"[REPEAT THIS FORMAT FOR EVERY PROBLEM]","text":"<pre><code>\n---\n\n## How to Use the Template\n\n### For Every Problem:\n\n1. **Date &amp; Time:** Track when you solved it, how long\n2. **Problem Statement:** 1-line summary\n3. **Approach:** Naive AND optimal (always compare)\n4. **Solution:** Code both, with complexity analysis\n5. **Mistakes:** THIS IS KEY\n   - What did you do wrong?\n   - WHY did you do it? (root cause)\n   - How much time did it cost?\n   - How will you prevent next time?\n6. **Decision Chain:** Show your thinking path\n7. **Testing:** Trace on paper for 2-3 examples\n8. **Key Insights:** What pattern/precondition unlocked this?\n9. **Similar Problems:** Link to related problems\n10. **Follow-ups:** What would interviewer likely ask?\n\n### Optional But Helpful:\n\n- **Comparison to Reference:** How did your solution compare?\n- **Lessons:** General takeaways for future problems\n- **Confidence Level:** 1-10 how confident you are in this solution\n- **Repeat Date:** If you solve this again, note the date and compare\n\n---\n\n## What Makes a Good Practice Diary Entry\n\n### \u2705 GOOD\n```markdown\n**Mistakes:**\n1. Tried to optimize immediately\n   - Why: Wanted to show off\n   - Root cause: Overconfidence\n   - Cost: 10 minutes, then realized naive was clearer\n   - Prevention: \"Write naive first, let interviewer suggest optimization\"\n</code></pre>"},{"location":"practice-diary/#bad","title":"\u274c BAD","text":"<pre><code>**Mistakes:**\n1. Forgot to handle NULL\n</code></pre> <p>^ Too vague! Doesn't prevent future mistake</p>"},{"location":"practice-diary/#good","title":"\u2705 GOOD","text":"<pre><code>**Decision Chain:**\nStart \u2192 \"Two numbers?\" \u2192 \"Use hash map?\" \u2192 \"Store num\u279cindex\" \u2192 Check complement BEFORE store \u2713\n</code></pre>"},{"location":"practice-diary/#bad_1","title":"\u274c BAD","text":"<pre><code>**Decision Chain:**\nUsed hash map and it worked\n</code></pre> <p>^ No insight into your thinking</p>"},{"location":"practice-diary/#sample-weekly-review","title":"Sample Weekly Review","text":"<p>Every 5 problems, review your diary:</p> <pre><code># Weekly Review: Feb 15-22\n\n## Problems Solved\n1. Two Sum - \u2705 28 min (slow but understood)\n2. Valid Parentheses - \u2705 12 min (stack easy)\n3. Longest Substring - \u26a0\ufe0f 45 min (sliding window tricky)\n4. Merge Intervals - \u2705 18 min (good)\n5. Binary Search - \u2705 10 min (sorted prerequisite!)\n\n## Recurring Mistakes\n\u274c Forgetting to check edge cases first (2 out of 5)\n\u274c Optimizing before ensuring naive works (1 out of 5)\n\u2705 Improving: Tracing on paper first (helped 4 out of 5)\n\n## Pattern Confusions\n- Sliding window: Need to understand \"can reuse?\" precondition\n- Two pointers: When? Requires sorted OR two ends\n\n## Next Week Focus\n1. Sliding window: Do 3 more problems, each time verify precondition\n2. Binary search: Do 2 more, understand sorted requirement\n3. Maintain: Paper trace EVERY problem (working well)\n\n## Time Trends\n| Problem Count | Avg Time | Status |\n|---|---|---|\n| 1-5 | 22.6 min | Slow (target 10-15) |\n| Next goal | 15 min | Need 30% speed up |\n</code></pre>"},{"location":"practice-diary/#how-to-organize-your-diary","title":"How to Organize Your Diary","text":""},{"location":"practice-diary/#structure","title":"Structure","text":"<pre><code>practice-diary/\n\u251c\u2500\u2500 2026-02-15-two-sum.md\n\u251c\u2500\u2500 2026-02-15-valid-parentheses.md\n\u251c\u2500\u2500 2026-02-16-longest-substring.md\n\u251c\u2500\u2500 WEEKLY-REVIEW-2026-02-15.md\n\u251c\u2500\u2500 MONTHLY-REVIEW-2026-02.md\n\u2514\u2500\u2500 PATTERNS.md (index of all patterns learned)\n</code></pre>"},{"location":"practice-diary/#pattern-index-example","title":"Pattern Index Example","text":"<pre><code># Pattern Index\n\n## Hash Map Problems\n- Two Sum (\u2705 28 min)\n- Valid Anagram (\u2705 15 min)\n- Group Anagrams (\u26a0\ufe0f 42 min - review)\n\n## Sliding Window Problems  \n- Longest Substring (\u26a0\ufe0f 45 min - precondition unclear)\n- Max Sum Subarray (\u2705 12 min)\n\n[etc...]\n</code></pre>"},{"location":"practice-diary/#common-patterns-to-track","title":"Common Patterns to Track","text":"<p>As you go through problems, note patterns in your diary:</p>"},{"location":"practice-diary/#pattern-hash-map-for-lookup","title":"Pattern: Hash Map for Lookup","text":"<pre><code>When to use:\n- \"Find X in array where property Y\"\n- \"Complement lookup\"\n- \"Count frequencies\"\n\nKey insight:\n- Store key\u279cvalue while iterating\n- Lookup = previous element met condition\n</code></pre>"},{"location":"practice-diary/#pattern-sliding-window","title":"Pattern: Sliding Window","text":"<pre><code>When to use:\n- Subarray/substring problems\n- When can reuse portion of result\n\nPrecondition:\n- \"Are we adding/removing ends?\"\n- \"Is previous result relevant?\"\n</code></pre>"},{"location":"practice-diary/#pattern-two-pointers","title":"Pattern: Two Pointers","text":"<pre><code>When to use:\n- Sorted array\n- Find pair with constraint\n- Container with most water\n\nPrecondition:\n- Array must be sorted\n- Working from both ends\n</code></pre>"},{"location":"practice-diary/#practice-diary-metrics-to-track","title":"Practice Diary Metrics to Track","text":""},{"location":"practice-diary/#weekly-metrics","title":"Weekly Metrics","text":"<ul> <li>[ ] Problems solved this week: ___</li> <li>[ ] Average time: ___</li> <li>[ ] Success rate (first try): ___%</li> <li>[ ] Bug rate: ___%</li> </ul>"},{"location":"practice-diary/#progress-tracking-template","title":"Progress Tracking Template","text":"<pre><code>Week 1 (Feb 15-21):\n- Problems: 5\n- Avg time: 22.6 min\n- Success: 80% (4/5 first try)\n- Bugs: 40% (2/5 had bugs)\n\nWeek 2 (Feb 22-28):\n- Problems: 8\n- Avg time: 18.2 min \u2190 Improving!\n- Success: 87.5% (7/8 first try) \u2190 Improving!\n- Bugs: 25% (2/8 had bugs) \u2190 Improving!\n</code></pre>"},{"location":"practice-diary/#red-flags-in-your-diary","title":"Red Flags in Your Diary","text":""},{"location":"practice-diary/#stop-if-you-see","title":"\ud83d\udea8 Stop if You See:","text":"<ul> <li>Same mistake appearing 3+ times \u2192 You didn't learn</li> <li>Time increasing or flat \u2192 Not improving speed</li> <li>Zero testing \u2192 Will fail edge cases</li> <li>No root cause analysis \u2192 Wasting diary time</li> <li>Solutions look memorized (not your own words) \u2192 Memorization trap</li> </ul>"},{"location":"practice-diary/#good-signs","title":"\u2705 Good Signs:","text":"<ul> <li>Mistakes decreasing week-over-week</li> <li>Time improving (faster and fewer bugs)</li> <li>Always testing on paper first</li> <li>Can explain preconditions</li> <li>Similar problems instantly recognizable</li> </ul>"},{"location":"practice-diary/#how-to-git-commit-your-diary","title":"How to Git Commit Your Diary","text":"<pre><code># After completing a problem\ncd d:/dsa\ngit add practice-diary/2026-02-15-two-sum.md\ngit commit -m \"Add: Two Sum practice diary (28 min, hash map pattern)\"\ngit push origin main\n\n# Weekly review\ngit add practice-diary/WEEKLY-REVIEW-2026-02-15.md\ngit commit -m \"Review: Week 1 - 5 problems, patterns index updated\"\ngit push origin main\n</code></pre> <p>Your GitHub will show your learning progress over time! This is impressive for interviews too.</p> <p>The bottom line: Practice diary separates successful interview prep from wasted hours.</p> <p>Not keeping one? You're repeating mistakes and not learning patterns.</p> <p>Keeping one? Every problem teaches you something new, repeated mistakes disappear, confidence grows.</p> <p>\ud83d\udcaa Keep the diary. It works.</p> <p>Next: Ready to start? Head to your DSA repo and create your first practice diary entry!</p>"},{"location":"system-design-guide/","title":"\ud83d\udcd6 System Design Interview Guide","text":""},{"location":"system-design-guide/#the-7-system-design-gotchas-to-avoid","title":"The 7 System Design Gotchas to Avoid","text":"<p>Based on comprehensive analysis of \"You Suck At Coding Interviews\" guide.</p>"},{"location":"system-design-guide/#1-premature-component-specification-most-common","title":"1\ufe0f\u20e3 Premature Component Specification \u2b50 MOST COMMON","text":"<p>Failure Pattern:</p> <pre><code>Interviewer: \"How would you scale Twitter?\"\nYou: \"We'll use MongoDB, Redis, Nginx, Kafka, Cassandra...\"\nInterviewer: \"Why MongoDB?\"\nYou: \"Because... it scales?\"\nInterviewer: \u274c FAIL\n</code></pre> <p>Root Cause: Tech stack memorization, not reasoning</p> <p>Why It Happens:  - You've heard MongoDB used at scale - Don't understand WHY it was chosen - Can't defend your choice when questioned</p> <p>Fix: Start with PROBLEM characteristics, then JUSTIFY tech choice</p> <p>Correct Pattern:</p> <pre><code>\u274c \"We need MongoDB\"\n\n\u2705 \"We need to store non-relational data with horizontal scaling.\n   MongoDB provides this by sacrificing consistency for availability.\n   Trade-off: eventual consistency acceptable for tweets,\n   critical for follower list (use relational here)\"\n</code></pre> <p>The Framework: 1. Problem: Define constraints (DAU, QPS, storage) 2. Need: What characteristic solves this? (consistency? horizontal scale? fast reads?) 3. Technology: Which tech provides this? (justify) 4. Trade-off: What are we sacrificing? (name it)</p> <p>Example:</p> <pre><code>Problem: 500M tweets/month, 100K QPS, read-heavy (100:1 ratio)\nNeed: Horizontal scaling, fast reads, eventual consistency OK\nTechnology: Cassandra (distributed, read-optimized)\nTrade-off: No powerful queries, eventual consistency\n\nNOT \"Cassandra is cool\" - that fails immediately\n</code></pre>"},{"location":"system-design-guide/#2-the-free-lunch-fallacy","title":"2\ufe0f\u20e3 The Free Lunch Fallacy","text":"<p>Myth: \"NoSQL scales better than SQL\"</p> <p>Truth: NoSQL trades consistency/joins for scale - no magic</p> <p>Reality Check:</p> Aspect MySQL NoSQL Joins \u2705 Fast, powerful \u274c Complex, app-level horizontal scale \u26a0\ufe0f Hard (sharding) \u2705 Built-in Consistency \u2705 Strong \u274c Eventual ACID \u2705 Yes \u274c Varies Simplicity \u2705 SQL predictable \u274c Schema-less surprises <p>Your Takeaway: EVERY choice costs something. Name the cost.</p> <p>Interview Example:</p> <pre><code>You: \"Let's use NoSQL for everything, it scales better\"\nInterviewer: \"What if we need to transfer money between accounts?\"\nYou: \"...that needs ACID transactions\"\nInterviewer: \"NoSQL \u2717 ACID \u2717 Trade-off \u2717\"\n\nBetter:\nYou: \"NoSQL for user timeline (eventual consistency OK)\nSQL for transactions (need ACID)\nReason: NoSQL scales horizontally, SQL has strong guarantees\"\n</code></pre> <p>Common Free Lunch Beliefs: - \u274c \"Cache makes everything fast\" \u2192 Cache misses, invalidation complexity - \u274c \"Microservices solve scalability\" \u2192 Network latency, distributed tracing - \u274c \"Multiple databases = best solution\" \u2192 Operational complexity, debugging nightmares</p>"},{"location":"system-design-guide/#3-not-calculating-capacity-causes-wrong-design","title":"3\ufe0f\u20e3 Not Calculating Capacity \u2b50 CAUSES WRONG DESIGN","text":"<p>What Fails: Design without numbers</p> <p>Example:</p> <pre><code>Interviewer: \"Design YouTube\"\nYou: \"Multiple servers, load balancer, cache, database\"\nInterviewer: \"How many servers?\"\nYou: \"Uh... as many as needed?\"\nInterviewer: \u274c FAIL\n</code></pre> <p>Why Numbers Matter: Wrong capacity \u2192 completely different architecture</p> <p>Example Calculation:</p> <pre><code>500M URLs created/month\n\u00f7 30 days \u00f7 86,400 seconds = 200 writes/sec\n\n100:1 read/write ratio = 20,000 reads/sec\n\nEach URL entry: 500 bytes average\n\n3 years retention:\n  500M URLs/month \u00d7 36 months = 18B total URLs\n  18B URLs \u00d7 500 bytes = 9,000,000,000,000 bytes = 9TB\n\nStorage conclusion: 9TB requires SHARDING\nWrite throughput: 200/sec fine on single server\nRead throughput: 20K/sec needs multiple replicas/caches\n</code></pre> <p>Your Action: ALWAYS calculate these FIRST:</p> <ol> <li>DAU (Daily Active Users)</li> <li>1M DAU? 100M DAU? 1B DAU?</li> <li> <p>Completely different scale</p> </li> <li> <p>QPS (Queries Per Second)</p> </li> <li>Calculation: DAU \u00d7 avg requests/user \u00f7 86,400 seconds</li> <li> <p>Makes capacity clear</p> </li> <li> <p>Storage</p> </li> <li>Calculation: QPS \u00d7 avg data size \u00d7 retention period</li> <li> <p>Determines: single server vs sharding vs archival</p> </li> <li> <p>Bandwidth</p> </li> <li>Calculation: QPS \u00d7 avg data size</li> <li>Determines: network, API gateway capacity</li> </ol> <p>Complete Calculations for URL Shortener:</p> <pre><code>DAU: 1M users\nAvg URLs created: 10/day\nQPS: 1M \u00d7 10 \u00f7 86,400 = 115 writes/sec\nRead/write ratio: 100:1 = 11,500 reads/sec\n\nStorage per URL:\n- Short code: 7 bytes\n- Long URL: 1KB\n- Metadata: 100 bytes\n- Total: ~1.1KB\n\nYearly storage: 115 writes/sec \u00d7 86,400 sec \u00d7 365 days \u00d7 1.1KB\n= 115 \u00d7 86,400 \u00d7 365 \u00d7 1.1KB = 3.6TB/year\n\n5-year retention: 18TB (needs sharding? probably not at this scale)\n</code></pre> <p>Design Impact: - 115 writes/sec \u2192 single DB server fine (can handle 1000s) - 11,500 reads/sec \u2192 need caching + replicas - 18TB \u2192 if using single drive, archive old data</p>"},{"location":"system-design-guide/#4-missing-non-functional-requirements","title":"4\ufe0f\u20e3 Missing Non-Functional Requirements","text":"<p>What Most Candidates Do: Only plan functional (create, read, delete)</p> <p>What You Must Do: Also define NFRs</p> <p>Non-Functional Requirements: - Latency: How fast must response time be? - Availability/SLA: What's acceptable downtime? (99%, 99.9%, 99.99%) - Consistency Model: Strong? Eventual? Causal? - Throughput: Requests/second targets?</p> <p>Example Failure:</p> <pre><code>Candidate: \"We store URLs in database, cache in Redis\"\nInterviewer: \"If Redis dies?\"\nCandidate: \"Use the database...\"\nInterviewer: \"Latency impact?\"\nCandidate: \"It will be slow?\"\n\nInterviewer: \"By how much? 1s? 10s? 1m?\"\nCandidate: \"I don't know?\"\nInterviewer: \u274c FAIL - No latency SLA defined\n</code></pre> <p>Better Approach:</p> <pre><code>\"Our latency SLA: p99 &lt; 100ms\nIf Redis dies:\n  - Fallback to database (slower, ~500ms)\n  - Degrade: show cached version if available\n  - Alert: page on-call to rebuild Redis (RTO 5 min)\n  - This keeps p99 &lt; 500ms temporarily\"\n</code></pre> <p>NFR Examples Per System:</p> System Latency SLA Availability Consistency Twitter p99 &lt; 100ms 99.9% Eventual Uber p99 &lt; 50ms 99.95% Strong Gmail p99 &lt; 1s 99.99% Strong Analytics p99 &lt; 1m 95% Eventual"},{"location":"system-design-guide/#5-ignoring-failure-scenarios","title":"5\ufe0f\u20e3 Ignoring Failure Scenarios","text":"<p>Problem: Your design works when everything is fine. Fails under chaos.</p> <p>Common Failures:</p>"},{"location":"system-design-guide/#network-partition","title":"Network Partition","text":"<pre><code>Problem: Server A can't reach Server B\nQuestion: Timeout? Retry? Failover?\n\nDesign flaw: \n  You: \"Server A waits for Server B response forever\"\n  \u2192 Cascading failure\n\nBetter:\n  You: \"1-second timeout, after 3 retries \u2192 failover to backup\"\n</code></pre>"},{"location":"system-design-guide/#replica-lag","title":"Replica Lag","text":"<pre><code>Problem: Write on primary, read from stale replica\nQuestion: How old is acceptable?\n\nDesign flaw:\n  You: \"Just replicate, don't worry about lag\"\n  \u2192 User writes comment, reads stale feed (comment missing)\n\nBetter:\n  You: \"For read-after-write: read-through-primary\n       For other reads: eventual consistency (&lt; 1s lag)\n       Monitor and alert if lag &gt; threshold\"\n</code></pre>"},{"location":"system-design-guide/#cascading-failures","title":"Cascading Failures","text":"<pre><code>Problem: Service A slow \u2192 timeouts \u2192 Service B backed up\n        \u2192 Thread pool exhausted \u2192 Service B fails\n        \u2192 Service C can't call B \u2192 Service C fails\n\nDesign flaw: No circuit breakers, no bulkheads\n\nBetter:\n  Circuit breaker: If B fails, C stops calling B immediately\n  Bulkhead: Limit threads per downstream service\n  Timeout: Short timeout so C doesn't wait forever\n</code></pre>"},{"location":"system-design-guide/#data-loss","title":"Data Loss","text":"<pre><code>Problem: Hard drive fails, data lost\nQuestion: Do you have replicas? Backups? How many?\n\nDesign flaw:\n  You: \"Just use the database\"\n  \u2192 One server dies, all data gone\n\nBetter:\n  You: \"3-replica Cassandra cluster (replication factor 3)\n       Nightly snapshots to S3\n       RTO 5 minutes, RPO 1 hour\"\n</code></pre> <p>Your Mitigation Strategy (per failure type): - Timeouts: Kill slow requests - Circuit Breakers: Stop calling failed services - Fallbacks: Use cache, degraded service, backup - Monitoring: Alert on errors, latency - Redundancy: Multiple replicas, multiple datacenters</p>"},{"location":"system-design-guide/#6-not-discussing-tradeoffs-explicitly","title":"6\ufe0f\u20e3 Not Discussing Tradeoffs Explicitly","text":"<p>Failure: Propose solution, move on.</p> <p>Success: State what you're sacrificing for each choice.</p> <p>Interview Example:</p> <pre><code>You: \"I'd use hash-based sharding\"\nInterviewer: \"Tradeoffs?\"\nYou: \"Uh... none?\"\nInterviewer: \u274c FAIL - Every choice has costs\n\nBetter:\nYou: \"I'd use hash-based sharding for even distribution.\n     Trade-off: redistribution is expensive if cluster grows.\n     Benefit: no hot shards in normal operation.\n     Monitoring: watch for hot shards, if detected \u2192 migrate to directory-based.\"\n</code></pre> <p>Sharding Strategy Example:</p> Option Pro Con When Hash-Based Distributes evenly Expensive rebalance Initial deployment Range-Based Easy to add servers Uneven distribution (hot range) When ranges skew predictable Directory-Based Handles uneven Directory becomes bottleneck When many hot shards <p>Your Approach:</p> <pre><code>Initial: Hash-based sharding\n  - Assumption: even distribution\n  - Monitoring: track shard sizes\n\nIf observation: \"Shard 3 has 60% of data\"\n  - Root cause: hash function poor or data skewed\n  - Decision: Migrate to directory-based\n  - Justification: \"Accept directory overhead for uniform distribution\"\n</code></pre> <p>Always State Trade-offs Like: 1. \"I'm trading [cost A] for [benefit B]\" 2. \"Assumption: [X condition holds]\" 3. \"Monitoring alert: [Y metric becomes bad]\" 4. \"If [Y happens], migrate to: [backup plan]\"</p>"},{"location":"system-design-guide/#7-not-justifying-each-component","title":"7\ufe0f\u20e3 Not Justifying Each Component","text":"<p>Failure: \"Load balancer, API gateway, queue, cache, database...\"</p> <p>Reality: Many candidates can't justify each one</p> <p>You Must Be Able To Explain:</p> <pre><code>WHY load balancer? (1 sentence)\nWHY API gateway? (1 sentence)\nWHY queue? (1 sentence)\n</code></pre> <p>Correct Framework:</p> <pre><code>Problem \u2192 Solution \u2192 Component (justified)\n\nPROBLEM: 1M users, single server can handle 10K QPS max\nSOLUTION: Distribute load across multiple servers\nCOMPONENT: Load balancer \u2705\nJUSTIFICATION: \"Routes requests to available servers, handles failover\"\n\n\nPROBLEM: Different services (auth, tweets, feed) need different scales\nSOLUTION: Rate limit &amp; authenticate at entry point\nCOMPONENT: API gateway \u2705\nJUSTIFICATION: \"Centralized auth, rate limiting, request routing\"\n\n\nPROBLEM: Write spike (1M likes/sec) causes database lock\nSOLUTION: Buffer writes, process asynchronously\nCOMPONENT: Queue (Kafka, RabbitMQ) \u2705\nJUSTIFICATION: \"Decouples write spike from database, allows batch processing\"\n\n\nPROBLEM: Database queries take 500ms, users expect &lt; 100ms\nSOLUTION: Store frequently accessed data in fast memory\nCOMPONENT: Redis cache \u2705\nJUSTIFICATION: \"&lt; 5ms memory access vs 500ms disk access\"\n\n\nPROBLEM: Need durability &amp; consistency for transactions\nSOLUTION: Structured, ACID-compliant storage\nCOMPONENT: Primary database (PostgreSQL) \u2705\nJUSTIFICATION: \"Relational data with ACID guarantees\"\n</code></pre> <p>Anti-Pattern:</p> <pre><code>\u274c \"We'll use Kafka because it's cool\"\n\u274c \"Redis because Netflix uses it\"\n\u274c \"Mongo because no Schema\"\n\n\u2705 \"Kafka because we need to decouple writes at scale\"\n\u2705 \"Redis because sub-100ms reads critical\"\n\u2705 \"Mongo because schema evolves independently per service\"\n</code></pre>"},{"location":"system-design-guide/#system-design-study-strategy","title":"System Design Study Strategy","text":""},{"location":"system-design-guide/#the-study-flow","title":"The Study Flow","text":"<ol> <li>Study Existing Solutions (Grokking: 15h)</li> <li>Understand patterns, not memorize</li> <li> <p>Focus on WHY, not HOW</p> </li> <li> <p>Understand Theory (DDIA: 10h)</p> </li> <li>Read chapters on weak areas</li> <li> <p>Replication, partitioning, consistency</p> </li> <li> <p>Reverse Engineer Real Systems (5h)</p> </li> <li>Design Twitter without reading solutions</li> <li>Design Uber from scratch</li> <li> <p>Compare to real implementations</p> </li> <li> <p>Mock Interview (ongoing)</p> </li> <li>Practice talking through design</li> <li>Justify every choice</li> <li>Document tradeoffs</li> </ol>"},{"location":"system-design-guide/#key-questions-to-ask-yourself","title":"Key Questions to Ask Yourself","text":"<ul> <li>[ ] \"Can I calculate capacity for this system?\"</li> <li>[ ] \"What are the NFRs?\"</li> <li>[ ] \"What's my sharding strategy? Why?\"</li> <li>[ ] \"How does it handle failures?\"</li> <li>[ ] \"What's my monitoring strategy?\"</li> <li>[ ] \"Have I justified every component?\"</li> <li>[ ] \"Have I stated all tradeoffs?\"</li> </ul> <p>Next Step: See Study Timelines for benchmarks &gt;&gt;</p>"},{"location":"timelines/","title":"\u23f1\ufe0f Study Timelines &amp; Benchmarks","text":"<p>Based on \"You Suck At Coding Interviews\" guide recommendations.</p>"},{"location":"timelines/#dsa-study-timeline-115-hours-total","title":"DSA Study Timeline: 115 Hours Total","text":""},{"location":"timelines/#phase-1-foundations-0-35-hours","title":"Phase 1: Foundations (0-35 hours)","text":"<p>Material: Grokking patterns course (skip DP for now) Goal: Master 80%+ of patterns</p> Hours Check-in Milestone 5h Getting started Completed: 2-3 pattern types 10h Foundations Easy problems &lt; 15 min 20h Pattern lock-in Easy problems &lt; 10 min 30h Flow state Medium problems possible 35h Checkpoint 60% of Grokking complete <p>What You Can Do: - [ ] Identify pattern from problem name - [ ] Write multiple approaches - [ ] Trace through examples on paper - [ ] Explain preconditions</p> <p>Red Flags: - \u274c Still writing brute force after 10h - \u274c Can't explain why pattern works - \u274c Learning new pattern seeps into old</p>"},{"location":"timelines/#phase-2-dp-mastery-35-50-hours","title":"Phase 2: DP Mastery (35-50 hours)","text":"<p>Material: Grokking DP course Goal: Can solve DP problems independently</p> Hours Check-in Milestone 35h DP start Understand top-down approach 40h Mid-phase Can build memoization table 45h Near end Can solve 70% of medium DP 50h Complete DP patterns mastered <p>Why Separate: DP conceptually different, needs focus</p> <p>What You Can Do: - [ ] Identify overlapping subproblems - [ ] Build recurrence relation - [ ] Choose top-down vs bottom-up - [ ] Optimize space</p> <p>Red Flags: - \u274c Still looking at solutions after 40h - \u274c Code works but can't explain why - \u274c Memoization table approach fuzzy</p>"},{"location":"timelines/#phase-3-advanced-50-85-hours","title":"Phase 3: Advanced (50-85 hours)","text":"<p>Material: EPI chapters 5-16 + LeetCode medium Goal: All problems solvable (speed may vary)</p> Hours Check-in Milestone 50h 2/3 done All patterns understood 60h 70% there Most mediums solvable 70h 80% there Hard problems attempted 80h Near ready Mostly consistent 85h Checkpoint Ready for practice phase <p>What You Can Do: - [ ] Solve any medium problem given unlimited time - [ ] Identify pattern quickly - [ ] Only stuck on implementation details</p> <p>Red Flags: - \u274c Still forgetting patterns - \u274c Can't solve 50% of mediums - \u274c Solution time unpredictable (20-60 min variance)</p>"},{"location":"timelines/#phase-4-practice-interview-prep-85-115-hours","title":"Phase 4: Practice &amp; Interview Prep (85-115 hours)","text":"<p>Material: LeetCode mediums/hards mixed Goal: Interview-ready consistency</p> Hours Check-in Milestone 85h Start Solve random 10 problems 95h 10% done 70% success on first try 100h 20% done All solvable in &lt; 30 min 105h 30% done Behavioral + technical ready 110h 40% done Mock interviews clean 115h Complete Interview ready <p>What You Can Do: - [ ] Solve 70% of random problems first try - [ ] Speed: easy &lt; 5 min, medium &lt; 20 min - [ ] Explain solution clearly - [ ] Handle follow-up questions</p> <p>Red Flags: - \u274c Still making same mistakes - \u274c Solution time increasing - \u274c Confidence decreasing</p>"},{"location":"timelines/#dsa-benchmarks","title":"DSA Benchmarks","text":""},{"location":"timelines/#time-per-problem-level","title":"Time Per Problem Level","text":"Level 20h Benchmark 50h Benchmark 100h Benchmark Easy 10-15 min 5-10 min 2-5 min Medium 30-45 min 15-25 min 8-15 min Hard 60+ min 30-45 min 20-35 min"},{"location":"timelines/#quality-per-problem-level","title":"Quality Per Problem Level","text":"Level Bugs at 20h Bugs at 50h Bugs at 100h Easy 20-30% 5-10% 0-2% Medium 30-40% 10-15% 2-5% Hard 50-60% 25-35% 10-15%"},{"location":"timelines/#learning-curve-typical","title":"Learning Curve (Typical)","text":"<pre><code>Error Rate %\n|\n100 |\u25cf                      (Starting - lots of bugs)\n    | \u25cf\n 80 |  \u25cf\n    |   \u25cf\n 60 |    \u25cf\u25cf                (Fast learning 5-20h)\n    |      \u25cf\n 40 |       \u25cf\n    |        \u25cf\u25cf            (Plateau 30-50h)\n 20 |          \u25cf\u25cf\u25cf\n    |             \u25cf\u25cf\u25cf\u25cf\u25cf    (Slow improvement 70-100h)\n  0 |___________________\u25cf\u25cf\n    0   20   40   60   80  100 Hours\n</code></pre> <p>Interpretation: - 0-15h: Rapid learning (steep drop) - 15-50h: Consolidation (gradual drop) - 50-100h: Refinement (slow drop to expert)</p>"},{"location":"timelines/#system-design-timeline-30-hours","title":"System Design Timeline: 30+ Hours","text":""},{"location":"timelines/#phase-1-study-solutions-0-15-hours","title":"Phase 1: Study Solutions (0-15 hours)","text":"<p>Material: Grokking System Design interview course (5-10 case studies) Goal: Learn patterns</p> Hours Case Studies Milestone 3h 1 (URL Shortener) Understand HLD/LLD structure 6h 2 (Twitter) See pattern: API \u2192 workers \u2192 DB 9h 3 (YouTube) Understand caching strategy 12h 4 (Uber real-time) Understand WebSocket patterns 15h 5+ (Your choice) Pattern recognition locked in <p>What You Learn: - HLD (High-level design) components - LLD (Low-level design) code patterns - Tradeoff thinking - Capacity calculations</p> <p>Red Flags: - \u274c Just copying Grokking solutions - \u274c Can't explain why choice was made - \u274c Can't calculate capacity yourself</p>"},{"location":"timelines/#phase-2-understand-theory-15-25-hours","title":"Phase 2: Understand Theory (15-25 hours)","text":"<p>Material: DDIA (Designing Data-Intensive Applications) key chapters Goal: Understand WHY</p> Hours Reading Deep Dive 2h Ch 5: Replication Multi-master, consistency models 2h Ch 6: Partitioning Sharding strategies, rebalancing 2h Ch 9: Consistency &amp; Consensus CAP theorem, algorithms 2h Ch 11: Stream Processing Events, message queues 2h Review + Synthesis Connect theory to case studies <p>What You Learn: - WHY replication? (High availability, read scaling) - Consistency models (strong, eventual, causal) - Sharding strategies (hash, range, directory) - Failure modes and recovery</p> <p>Red Flags: - \u274c Too abstract, can't connect to systems - \u274c Only reading, not annotating</p>"},{"location":"timelines/#phase-3-reverse-engineer-25-30-hours","title":"Phase 3: Reverse Engineer (25-30 hours)","text":"<p>Material: Design similar systems without reading solutions Goal: Can apply independently</p> Hours Exercise Difficulty 2h Design URL Shortener Medium 2h Design Twitter Hard 2h Design YouTube Hard 1h Design Messaging Medium 2h Design Rate Limiter Easy <p>Your Approach: 1. Design in text/whiteboard (no peeking) 2. Write down: requirements, capacity, HLD, LLD 3. Compare to reference solutions 4. 50% match? You understand core 5. 80%+ match? You're ready for interviews</p> <p>Red Flags: - \u274c Can't complete without help - \u274c Designs completely different from reference - \u274c Missing capacity calculations</p>"},{"location":"timelines/#phase-4-interview-ready-30h","title":"Phase 4: Interview Ready (30h+)","text":"<p>Material: Mock interviews, follow-up questions Goal: Handle real interviews</p> Hours Activity Focus 2-3h Full mock interview Time pressure, clarity 1h Feedback review Identify weak areas 1h Targeted study Fix weak areas Repeat Going forward 2-3 mocks/week <p>What Success Looks Like: - [ ] Latency SLA defined within 1 min - [ ] Capacity calculated without mistakes - [ ] HLD clear, all components justified - [ ] Tradeoffs explicit - [ ] Failure scenarios identified - [ ] Can defend every choice</p>"},{"location":"timelines/#combined-study-schedule","title":"Combined Study Schedule","text":""},{"location":"timelines/#month-1-dsa-foundations-system-design-intro","title":"Month 1: DSA Foundations + System Design Intro","text":"<pre><code>Week 1-2: DSA Phase 1 (0-15h)\nWeek 3-4: DSA Phase 1 (15-35h) + System Design Phase 1 start (0h)\n</code></pre>"},{"location":"timelines/#month-2-dsa-dp-system-design-solutions","title":"Month 2: DSA DP + System Design Solutions","text":"<pre><code>Week 1: DSA Phase 2 (35-42h)\nWeek 2: DSA Phase 2 (42-50h)\nWeek 3-4: DSA Phase 3 start (50-60h) + System Design Phase 1 complete (15h)\n</code></pre>"},{"location":"timelines/#month-3-dsa-advanced-system-design-theory","title":"Month 3: DSA Advanced + System Design Theory","text":"<pre><code>Week 1-2: DSA Phase 3 (60-75h)\nWeek 3: DSA Phase 3 (75-85h) + System Design Phase 2 (20-25h)\nWeek 4: DSA Phase 4 start (85+) + System Design Phase 2 complete (25h)\n</code></pre>"},{"location":"timelines/#month-4-dsa-practice-system-design-practice","title":"Month 4: DSA Practice + System Design Practice","text":"<pre><code>Ongoing: DSA Phase 4 (85-115h) + System Design Phase 3-4 (25-30h+)\n2-3 mock DSA interviews/week\n1-2 mock System Design interviews/week\n</code></pre>"},{"location":"timelines/#benchmark-checkpoints","title":"Benchmark Checkpoints","text":""},{"location":"timelines/#at-20-hours","title":"At 20 Hours","text":"<ul> <li>[ ] DSA: Completed 20% of Grokking</li> <li>[ ] Easy problems &lt; 10-15 min</li> <li>[ ] Can explain 3 patterns clearly</li> <li>[ ] System Design: Not started (OK)</li> </ul>"},{"location":"timelines/#at-50-hours","title":"At 50 Hours","text":"<ul> <li>[ ] DSA: Completed 50% of Grokking + EPI start</li> <li>[ ] Medium problems 15-25 min</li> <li>[ ] Can solve 80% first attempt</li> <li>[ ] System Design: Completed 1-2 case studies</li> </ul>"},{"location":"timelines/#at-100-hours","title":"At 100 Hours","text":"<ul> <li>[ ] DSA: 85+ hours complete, interview ready</li> <li>[ ] Can solve 70% of 20 random problems first try</li> <li>[ ] Speed consistent, few bugs</li> <li>[ ] System Design: 2-3 case studies, theory started</li> </ul>"},{"location":"timelines/#at-145-hours-dsa-115-system-design-30","title":"At 145 Hours (DSA 115 + System Design 30)","text":"<ul> <li>[ ] DSA: Interview ready \u2705</li> <li>[ ] System Design: Interview ready \u2705</li> <li>[ ] Mock interviews going well</li> <li>[ ] Behavioral prep next</li> </ul>"},{"location":"timelines/#tips-for-staying-on-schedule","title":"Tips for Staying on Schedule","text":"<ol> <li>Track daily: Log hours, problems solved, mistakes</li> <li>Adjust weekly: Behind? Add 5h next week</li> <li>Red flags: If behind at checkpoint, redo that phase</li> <li>Don't rush: Better to add weeks than skip depth</li> </ol> <p>Next Step: See Interview Checklists to verify readiness &gt;&gt;</p>"}]}